# 12장 - 최적화 및 일반화 회피

---

> 이번 장에서 다루는 내용
>
> - 일반성을 최소화해서 커플링 최소화하기
> - 불변속성 측면에서 최적화 바라보기
> - 최적화를 통해 취약성 관리하기

이번 장에서 **최적화**라고 하면 **성능 최적화를 의미**, **일반화**는 매개변수를 통해 **더 많은 기능을 포함**하는 것을 의미

일반화가 의미하는 바와 그것이 어떻게 해로운지에 관해 설명이 나온다. (추상화의 느낌)

---

## 12.1 - 단순성 추구

- 이 책의 근본적인 주제는 단순함을 추구하는 것이다.
- 왜 그런 일반화나 최적화가 필요한지에 대한 확실한 증거가 있어야 한다.

## 12.2 - 일반화의 시기와 방법

- 메서드나 클래스에 일반화를 추가하기 전에 그렇게 해야 하는 이유가 있어야 된다.

### 12.2.1 - 구현의 최소화로 일반화 지양하기

- 복제, 변환, 통합의 3단계 방법은 기능이 최소한인 경우에만 최소한의 일반화를 보장한다.
- 최소한으로 구축하기 위한 끊임없이 노력해야 한다.

### 12.2.2 - 안정성이 유사한 것 통합하기

- 저자의 경험상 새로운 것과 오래된 것을 바로 통합하지 말라고 한다.
- 통합 대상이 비슷한 안정성에 도달할 때 통합하는 것이 좋다.

### 12.2.3 - 불필요한 일반화 제거

- 불필요한 일반화에 대해 정기적으로 모니터링해서 발견 시 제거해야 한다.
- 불필요한 일반화를 찾는 효과적인 방법은 **함수에 전달된 런타임 인자들을 모니터링** 하는 방법이 있다.

## 12.3 - 최적화 시기와 방법

- 일반화와 마찬가지고 필요성이 납득되어야 하며, 이게 잘 못 될 경우 인지부하에 걸린다.
- 자동 성능 테스트를 설정하고 테스트가 실패할 때만 최적화하는 것이 좋다.
    - 이 방식의 일반적인 유형은 다음과 같다.
    - ***“이 메서드는 14ms 안에 종료되어야 한다.”***
        - **벤치마크 테스트**라고 하고, 제한 시간 내 답변 해야 되는 (임베디드나 실시간 시스템에서 사용 됨)
        - 프로덕션과 유사한 환경에서만 벤치마크 테스트를 안정적으로 실행할 수 있다.
    - ***“이 서비스는 초당 1000개의 요청을 처리할 수 있어야 한다.”***
        - **부하 테스트**라고 하고 **처리량을 검증**한다. (웹, 클라우드 기반 시스템에서 사용 됨)
        - 벤치마크 테스트보다 외부 요인에 대해 더 탄력적이지만 프로덕션과 같은 하드웨어가 필요하다.
    - ***“이 테스트를 실행하면 마지막으로 실행했을 때보다 10% 이상 느려지지 않아야 한다.”***
        - **성능 승인 테스트**라고 부르고, **성능이 저하되지 않는지 확인**한다.
        - 실행 간에 일관성이 있는 한 외부 요인관 완전리 분리된다.

### 12.3.1 - 최적화 전 리팩터링

- 코드가 적절하게 리팩터링 되었는지 확인하고 시작해야 한다.
- 불변속성을 지역화해서 더 명확하게 만들어야 된다. (최적화는 불변속성에 의존하기 때문)
- 과시용으로 코드를 짜면 안 된다.

### 12.3.2 - 제약 이론에 따른 최적화

- 코드를 리팩터링 한 후 만족스럽지 않다면 최적화를 해야 한다.
- 병목현상에 대해서는 **리소스 풀링** 같은 절묘한 해결책이 있다. [**[관련 자료](https://psyhm.tistory.com/50)**]

### 12.3.3 - 측정 지표를 사용한 최적화

- 리소스 풀링을 적용해도 성능 요구사항을 만족하지 못하면 **병복 지점 내에서 최적화**를 해야 한다.
- 코드 내에서 병목 지점이 어디인지 부터 찾아야 한다. 이를 `핫 스팟(Hot spot)`이라고 한다.
    - 스레드가 대부분의 시간을 보내는 지점이 핫 스팟이고, **프로파일링** 도구를 사용해도 되지만, \
      수동으로 소요 시간을 측정할 수도 있다. (드릴다운이라고 표현함)

### 12.3.4 - 좋은 알고리즘과 데이터 구조 선택하기

- 하나의 데이터 구조를 동등한 인터페이스를 가진 다른 데이터 구조로 바꾸자.

### 12.3.5 - 캐시 사용하기

- 캐시는 안전하게 최적화 할 수 있는 방법 중 하나이다.
- 계산을 여러 번 수행하는 대신 한 번 수행하고 결과를 저장한 후 재사용 하는 방법이다.
- 캐시는 멱등 불변속성과 조합될 때 가장 안전하다.
    - 멱등성 : 동일한 인자로 호출하면 항상 동일한 결과가 나오게

### 12.3.6 - 최적화된 코드 분리하기

- 위 모든 사항을 적용해도 성능이 부족한 경우 **마이크로 최적화**라는 방법으로 성능 튜닝을 해야 한다.
- 런타임과 원하는 동작 사이에 존재하는 작은 불변속성을 이용한다.
- 튜닝된 코드를 위한 전용 패키지를 사용하는 것이 좋다.

## 요약

- 단순화는 코드가 요구하는 인지부하를 줄이는 것이다.
- 일반화는 코드 간의 결합 위험을 증가시킨다.
- 최소한의 구현으로 조합된 통합을 통해 일반화를 도입함으로써 불필요한 일반화를 도입하지 않는다.
- 안정성이 유사한 코드들만 결합해서, 결합을 통해 만들어진 일반화를 제거해야 하는 위험을 줄이자.
- 불필요한 일반화를 발견하거나 최적화할 후보를 찾을 때는 모니터링 및 프로파일링을 사용하자.
- 모든 최적화는 성능 테스트의 일부 형태인 지침에 따른 근거가 제시되어야 한다. (일상적인 업무로 최적화 x)
- 리팩터링을 통해 먼저 불변속성을 지역화 해야 된다. 최적화는 불변속성에 의존한다.
- 리소스 풀링은 도메인과 관련된 코드의 취약성을 높이지 않고 최적화 할 수 있다.
- 최적화 시 대상으로 기존 알고리즘과 데이터 구조 중에서 하나를 선택하는 것이 좋다.
- 캐시는 불변속성이 거의 없는 저렴하고 안전한 최적화가 될 수 있다.
- 성능 튜닝을 사용할 때는 사람들이 파악하는 데 시간을 낭비하지 않도록 튜닝된 코드를 격리해야 한다.