# 13장 - 나쁜 코드를 식별 가능하게 만들기

---

> 이번 장에서 다루는 내용
>
> - 좋은 코드와 나쁜 코드를 분리해야 하는 이유
> - 나쁜 코드의 유형
> - 안전하게 코드를 나쁘게 표시하기 위한 규칙
> - 코드를 나쁘게 표시하기 위한 규칙 적용

**안티 리팩터링**(**anti-refactoring**, 나쁜 코드를 안 좋아 보이게 만드는 것)에 대해서 얘기한다.

---

## 13.1 - 나쁜 코드에 대처하는 자세

- 애매하게 리팩터링 하는 것은 엉망진창인 상황을 그대로 두는 것보다 안 좋다.
    - 나쁜 코드를 남겨놓는 두 가지 장점
    1. 다시 찾기가 쉽다.
    2. 통제가 지속 가능하지 않다는 신호를 얻을 수 있다.

## 13.2 - 깨끗한 코드와 레거시 코드로 분리

- 잘 만들 수 없다면 눈에 띄게 만들어야 한다. 나쁜 코드가 잘 보일 수 있게
- 아주 좋은 코드의 기준을 넘을 수 있는 시간이나 기술이 없다면 ‘나쁘게’ 놔두어야 한다.
- 완전히 깨끗한 상태에 가장 가까운 파일부터 리팩터링을 시작하는 것이 좋다.
    - 일부 코드를 좋게 만들려면 주변 코드도 좋게 만들어야 한다. (깨진 유리창 이론)

### 13.2.1 - 깨진 유리창 이론

- 깨진 유리창 이론은 논란의 여지가 있어 완전히 맞다고 할 수는 없지만 최소한 은유적인 가치는 있다.
- 직관적으로 이해되는 부분까지 생각하면 된다.

## 13.3 - 나쁜 코드를 찾는 방법

- 좋은 코드, 나쁜 코드를 판단하는 완벽한 방법은 없지만 **코드가 얼마나 나쁜지 추정하는 방법**을 살펴보자.

### 13.3.1 - 이 책의 규칙: 단순하고 구체적인 코드

- 1부(1 ~ 6장)에서 다뤘던 내용들을 기억하면 된다. (ex). 호출 또는 전달 (추상화 수준을 맞추기 위해), … 등

### 13.3.2 - 코드 스멜: 완전하고 추상적인 코드

- ‘**마법 상수(magic constants, magic number)**’, ‘**코드 중복(Duplicated code)**’은 스멜이다.
    - **마법 상수**는 다음 중 하나를 뜻한다.
    - 설명할 수 없는 의미가 있는 고유한 값 또는 명명된 상수로 대체할 수 있는 다중 발생
    - 파일 형식이나 프로토콜을 식별하는 데 사용되는 상수 숫자 또는 텍스트 값
    - 다른 의미로 착각할 가능성이 없는 고유한 고유 값 (예: 전역 고유 식별자)

### 13.3.3 - 순환 복잡도: 알고리즘 (객관적)

- `13.3.1`, `13.3.2` 는 사람이 나쁜 코드를 찾아내는 방법인데, 이 부분은 컴퓨터가 나쁜 코드를 찾아낸다.
- 자동화된 코드의 품질 지표로 **순환 복잡도(cyclomatic complexity)**을 따진다.
    - **순환 복잡도** : 코드를 통과하는 경로의 수를 계산한다. (`if`, `while`, `||`, `&&`, … 등)
    - 메서드의 제어 흐름에 대해 계산된다.
    - 표현 수준에서 사람에게 항상 명확한 것은 아니다. (사람이 직접 하고 싶다면 `indent`로 비교하면 된다.)

### 13.3.4 - 인지 복잡도: 알고리즘 (주관적, 저자의 의견)

- **인지 복잡도(cognitive complexity)**를 활용하는 방법
    - **인지 복잡도** : 메서드를 읽는 동안 얼마나 많은 정보를 유지해야 하는지를 측정하는 지표
    - `13.3.3`의 순환 복잡도와 같이 들여쓰기로 점수를 체크할 수 있다.

## 13.4 - 코드를 안전하게 나쁜 코드로 보이기 위한 규칙

나쁜 코드를 눈에 띄게 만들 때는 다음의 세 가지 규칙을 따라야 한다.

1. 올바른 정보를 절대 훼손하지 말 것 (기존의 모든 정보 보존)
    - ex) 메서드 이름은 좋은데 본문이 지저분하다고 메서드 이름을 나쁘게 바꿔서는 안 된다.
    - 단, 오래되었거나 사소한 주석처럼 부정확하거나 불필요한 정보는 제거해도 된다.
2. 향후 리팩터링을 어렵게 만들지 말 것
    - 다른 사람을 위해 작업이 불편하게 만들지 않아야 된다. (내가 리팩터링 해야 되는 상황이 온다.)
    - 리팩터링하는 방법을 유도하는 것을 포함해 모든 정보를 표시해야 된다. (메서드 추출할 때 빈 줄 처럼)
3. 결과를 한눈에 알 수 있을 것
    - 코드가 신호로 인식되고 깨끗한 코드와 구분할 수 있는 눈에 띄는 차이가 있음을 보장해야 된다.

```
위 규칙에 따라 수행한 모든 것을 최악의 경우 쉽게 되돌릴 수 있어야 한다.
```

## 13.5 - 나쁜 코드를 나쁘게 보이기 위한 방법

- 팀에서 정의한 코드 스멜에 맞는 방법을 찾는 것이 좋다. (`13.4`의 세 가지 규칙을 어기지 않아야 된다.)

```
다음으로 제사하는 방법은 안전하고 쉽게 되돌릴 수 있다. (안전과 가역성은 필수)
```

### 13.5.1 - 열거형 사용

- `Boolean` 같은 타입 코드 대신 열거형을 사용하자.
    - 열거형은 추가하기가 일반적으로 빠르고 간단하며 쉽게 발견할 수 있다.
    - 리팩터링 하는 시간은 많이 걸리지만 간단하게 할 수 있다. 또한, 읽기가 더 쉽다.
- 조심해야 할 부분으론 다음과 같다.
    - 이 접근 방식이 정보를 파괴하지 않는지 고려해야 한다.
- 이 책의 `4.1.3`, `4.1.5`, `4.5.1` 을 적용해서 클래스 코드로 리팩터링 할 수 있다.

### 13.5.2 - 정수형 및 문자열을 타입 코드로 사용

- 열거형을 추가할 상황이 안 될 때는 `int`나 `string`을 타입 코드로 사용하는 것이 좋다.
- 문자열을 사용하면 텍스트가 상수 이름과 동일한 목적을 수행한다는 장점이 있다.
    - 문자열 타입 코드는 모든 값을 미리 선언할 필요가 없기 때문에 매우 유연하다.
    - 따라서, 빠른 실험이나 검증이 필요한 상황에서 사용할 수 있다.
- 정수형을 사용하는 경우에는 열거형으로 유도할 수 있다.

### 13.5.3 - 코드에 매직 넘버 넣기

- 매직 넘버는 타입 코드가 아닌 다른 방식으로 상수를 사용하는 방법이다.
- 리팩터링이 필요하다는 점을 강조하고 싶을 땐 코드에 매직 넘버를 사용하는 것이 좋다.
- 단, 이 기법을 사용하면 정보가 파괴될 위험이 있다. 따라서, 주석으로 정보를 추가하면 좋다.

### 13.5.4 - 코드에 주석 넣기

- `13.5.3`에서 얘기했듯이 주석으로 정보를 추가할 수 있다.
- 나중에 주석으로 된 부분이 메서드 추출할 때 메서드 명으로 하면 좋다.
- 위와 같이 주석으로 사용된 정보를 사용하는 상황을 대비해 무엇이든 정확하고 안전하게 적어야 된다.

### 13.5.5 - 코드에 공백 넣기

- 메서드를 분리할 위치를 제안할 수 있는 방법 중 하나이다.
- 이 접근 방식은 주석과 밀접하게 관련되어 있다. (주석과 비슷하지만 이름을 지을 만큼 충분히 않을 때 사용)

### 13.5.6 - 이름을 기준으로 항목을 그룹화하기

- 캡슐화의 후보들을 공통 접사로 붙인 다음 캡슐화 할 때를 생각하면 된다.
- 공통 접사들이 있으면 캡슐화를 적용해야 하는 신호로 볼 수 있다.

### 13.5.7 - 이름에 컨텍스트 추가하기

- 공통 접사를 적용할 때 **카멜케이스** 또는 **파스켈케이스** 형식의 이름에서 밑줄을 추가할 수 있다.
    - ex) `avg_ArrUtil`, `size_ArrUtil` → `_ArrUtil` 이러한 형식으로 **밑줄을 추가한 뒤 캡슐화**
- 단, 이 방법을 적용할 때 추가하는 컨텍스트가 정확해야 한다. (캡슐화하면 안 되는 메서드가 포함되지 않게)

### 13.5.8 - 긴 메서드 만들기

- 일부 메서드들이 만족스럽지 않게 추출되었다면 하나로 합쳐 긴 메서드로 만들 수 있다.
    - 긴 메서드는 대부분 경고 신호이므로 무언가를 수행해야 한다는 의미를 갖고 있기 때문
    - 만약, 만족스럽지 않게 추출된 상태로 냅두면 리팩터링이 더 어려울 수 있다.
- 이때 원본 메서드에 이름이 있고, 그 이름이 잘 못 되었는지 확신하지 않은 한 해당 정보를 보존해야 한다.

### 13.5.9 - 메서드에 많은 매개변수 넘기기

- 메서드가 많은 매개변수를 갖고 있으면 리팩터링의 필요성을 알 수 있다.
- 긴 매개변수 목록을 제거하기 위해서 어떤 매개변수가 결합되어 동일 클래스로 만들 수 있는지 등

### 13.5.10 - `getter`와 `setter` 사용하기

- 전역 변수나 공개 필드 대신 `getter`, `setter`를 만든 뒤 캡슐화를 보강할 때 사라지게 하면 된다.

---

```
캡슐화는 데이터를 리팩터링하는 첫 번째 단계이다. 더 쉽게 만들 뿐 아니라 더 간단하게 만든다.
```

## 요약

- 우선순위 똔느 시간 부족과 같은 절차적인 문제를 알리기 위해 나쁜 코드를 활용할 수 있다.
- 코드베이스를 깨끗한 코드와 레거시 코드로 분리해야 한다. (깨끗한 코드는 더 오래 유지되는 경향이 있음)
- ‘**나쁜 코드**’를 정의하는 완벽한 방법은 없지만 `코드 스멜`, `순환 복잡도`, `인지 복잡도`를 통해 유추할 수 있다.
- 다음 세 가지 규칙을 따르면 깨끗한 코드와 레거시 코드 사이의 간격을 안전하게 늘릴 수 있다.
    1. 정보를 절대 파괴하지 말 것
    2. 향후 리팩터링을 용이하게 할 것
    3. 문제의 가시성을 높일 것
- 위 규칙을 적용하는 구체적인 방법의 예
    - 열거형 사용
    - 정수 및 문자열을 타입 코드로 사용
    - 코드에 매직 넘버 넣기
    - 코드에 주석 넣기
    - 코드에 공백 넣기
    - 이름을 기준으로 항목을 그룹화하기
    - 이름에 컨텍스트 추가하기
    - 긴 메서드 만들기
    - 메서드에 많은 매개변수 넘기기
    - getter와 setter 사용하기