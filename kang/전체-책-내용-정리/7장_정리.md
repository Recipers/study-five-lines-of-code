# 7장 - 컴파일러와의 협업
---

- 이번 장부터 2부 이다.
    - 앞서 있었던 내용(1~6장)을 ‘현실 세계에서 적용하기’라는 문구로 시작한다.

> 이번 장에서 다루는 내용
>
> - 컴파일러의 장단점 이해
> - 컴파일러의 장점을 활용한 불변속성 제거
> - 컴파일러와 책임 분담

## 7.1 -  컴파일러에 대해 알아보기

### 7.1.1 - 약점: 정지 문제는 컴파일 시 알 수 있는 것을 제한한다.

- **정지 문제 (halting problem)**
    - 런타임 동안 어떤 일이 일어날지 정확히 말할 수 없는 이유
    - 간단하게 프로그램을 실행하지 않고는 프로그램이 어떻게 동작할지 할 수 없다.
    - 정지 문제에 관한 영상 : https://www.youtube.com/watch?v=92WHN-pAFCs
    - **정지 문제**는 판정 문제(decision problem)의 한 갈래로,
      - "주어진 [프로그램](https://namu.wiki/w/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8)이 해결하고자 하는 문제가 해결 가능한지 말해줄 수 있는 일반화된 [알고리즘](https://namu.wiki/w/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)이 존재하는가?" 라는 질문이다.
      - [나무위키, 정지 문제](https://namu.wiki/w/%EC%A0%95%EC%A7%80%20%EB%AC%B8%EC%A0%9C)

### 7.1.2 - 장점: 도달성 검증은 메서드의 반환을 보장한다.

- 메서드가 모든 경우(경로)에서 반환(return)되는지 확인하는 것이다.

### 7.1.3 - 장점: 확정 할당은 초기화되지 않은 변수에 대한 접근을 막는다.

- 컴파일러는 변수가 사용되기 전에 변수에 값이 할당되었는지 여부를 알아내는 데 능하다.

### 7.1.4 - 장점: 접근 제어로 데이터 캡슐화를 지원한다.

- 데이터를 캡슐화할 때 사용하는 접근 제어에도 컴파일러의 성능은 탁월하다.

### 7.1.5 - 장점: 타입(형) 검사기는 속성을 보증한다.

- 컴파일러는 타입 검사에 탁월하다.

### 7.1.6 - 약점: null을 역참조하면 애플리케이션이 손상된다.

- nullable 변수를 다룰 때 주의해야 한다.
- null을 적게 검사하는 것보다 가능한 한 많이 검사하는 것이 좋다.

### 7.1.7 - 약점: 산술 오류는 오버플로나 손상을 일으킨다.

- 0으로 나누기(또는 나머지) 연산 같은 산술 오류를 주의하자.

### 7.1.8 - 약점: 아옷-오브-바운드 오류는 애플리케이션을 손상시킨다.

- 범위 내에 있지 않은 인덱스에 접근하려고 하면 아웃-오브-바우드(out of bounds) 오류가 발생한다.

### 7.1.9 - 무한루프는 애플리케이션을 지연시킨다.

- 컴파일러는 무한루프를 감지하는 일에 도움이 되지 않으므로 조심해야 한다.

### 7.1.10 - 약점: 교착 상태 및 경쟁 상태로 인해 의도하지 않은 동작이 발생한다.

- 이 부분은 멀티스레딩에서 비롯된다.
- **경쟁 상태**, **교착 상태**, **기아 현상** 등 변경 가능한 데이터를 공유하는 여러 스레드가 있을때 조심하자.
    - 경쟁 상태 : **Race Condition** - [관련 자료](https://ko.wikipedia.org/wiki/%EA%B2%BD%EC%9F%81_%EC%83%81%ED%83%9C)
        - 두 개 이상의 스레드가 공유하는 변수를 읽고 쓰기 위해 경쟁할 때 발생
        - 이 문제를 해결하기 위해서는 잠금(Lock)을 도입해야 한다.
        - 어떤 프로그램을 실행하기 전에 각 스레드에 잠금을 부여하고 다른 스레드의 잠금을 해제됐는지 확인
            - 메타포, 세마포어, 뮤텍스 등등
    - 교착 상태 : **Dead Rock** - [관련 자료](https://ko.wikipedia.org/wiki/%EA%B5%90%EC%B0%A9_%EC%83%81%ED%83%9C)
    - 기아 현상 : ****Starvation**** - [관련 자료](https://itwiki.kr/w/%EA%B8%B0%EC%95%84_%ED%98%84%EC%83%81)
- 타입스크립트는 다중 스레드를 지원하지 않으므로 위의 오류들이 발생하지 않는다.

## 7.2 - 컴파일러 사용

- *프로그래밍은 건축이 아닌 **여러 단계의 커뮤니케이션**이다. - 마틴 파울러*
    - 따라서, 저자는 문학과 공통점이 많다고 한다.

### 7.2.1 - 컴파일러 활용

- TODO 리스트를 사용해 안정성 확보
    - 컴파일 오류를 TODO 리스트로 만든다.
- 순서 강제화를 이용한 안정성 확보
- 캡슐화 강제를 통한 안정성 확보
    - 접근 제한자를 통해 불변속성을 지역화
- 컴파일러로 사용하지 않는 코드 감지
    - IDE(or editor)를 활용하는 편이 더 좋을거 같다
- 확정 값을 통한 안정성 확보
    - 읽기 전용 필드를 이용해서 초기화되지 않은 필드를 사용할 수 없게

### 7.2.2 - 컴파일러와 싸우지 말 것

- **타입을 잘못 사용해서 타입 검사기를 무력화하지 말자** (다음 세 가지 방법으로 잘못 사용한다고 함)
    - **형 변환**
      - 책에서 나오는 예제는 웹 서비스에서 형식화되지 않는 JSON을 얻는 상황에 대해서 얘기한다.
        ```ts
            let num = <number> JSON.parse(variable); // 이렇게 사용하면 안 된다.
        ```
    - **동적 타입**
        - any를 사용하지 말자
    - **런타임 타입**
        - ex) 10개의 매개 변수가 잇는 메서드
        - 하나의 매개변수를 추가하거나 제거할 때마다 메서드를 호출하는 모든 곳에서 수정해야 하기 싫어서 Map을 사용하면 안 된다.
        - Map을 사용할 경우 컴파일러는 Map에 어떤 키가 있는지 알 수 업기 때문에 그렇다고 한다.
        - 특정 필드들을 객체로 만들어서 사용하는것이 더 좋다고 한다.
- **기본값**
    - 기본값을 사용하지 말자고 한다.
    - 231p 예제처럼 사용하는 상황이 있을까?
- **상속**
    - 상속은 기본값의 한 형태이고, 구현 클래스 간의 결합을 가져온다.
    - 무조건 사용하면 안 된다는 아니다. is a 관계에선 사용해도 된다.
- **처리를 강제하지 않은 예외**
    - Checked Exception, Unchecked Exception에 대해서 이야기한다.
    - try, catch를 사용해 에러 처리를 강제하게 하자고 한다.
- **아키텍처**
    - 만약 MSA 구조로 되어 있고, getter, setter를 사용하면 수신 측과 필드 사이에 결합이 만들어 진다.
    - MSA는 팀에 영향을 미치지만 다른 팀에 영향을 주면 안 된다.

## 7.3 - 컴파일러 신뢰하기

### 7.3.1 - 컴파일러에게 불변속성 가르치기


### 7.3.2 - 컴파일러의 경고에 주의를 기울일 것

- 깨진 유리창 이론에 대해 나오는데 [이 글](https://typefully.com/dylayed/ay5sbg7)을 읽어보면 깨진 유리창 이론의 이면이 있다.

## 7.4 - 컴파일러만 신뢰할 것

- 컴파일러 역시 사람이 작업한 것이 아닌가..?