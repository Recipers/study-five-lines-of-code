# 10장 - 코드 추가에 대한 두려움 떨쳐내기

---

> 이번 장에서 다룰 내용
>
> - 코드 추가에 대한 두려움의 증상
> - 코드 추가에 대한 두려움 극복
> - 코드 중복의 장단점 이해
> - 이전 버전과의 호환성 보장
> - 기능 토글로 위험 낮추기

---

```
코드 작성에 대한 두려움을 떨쳐내야 한다.
```

- 완벽한 코드는 비현실적인 목표이다.

## 10.1 - 불확실성 받아들이기: 위험 감수

- 스크럼(Scrum)의 5가지 핵심 가치 중 하나가 **용기**인 이유는 겁을 먹으면 효과적으로 일할 수 없다.
  - 스크럼의 5가지 핵심 가치 - https://aws.amazon.com/ko/what-is/scrum/

    #### 헌신
    스크럼 팀원은 시간이 정해진 작업과 목표에 전념하고 최상의 솔루션을 찾기 위해 지속적인 개선에 전념합니다.
    
    #### 용기 -> 이 책에서 나오는 부분
    스크럼 팀은 개방적이고 도전적인 질문을 함으로써 용기를 보여줍니다. \
    솔직하고 투명한 토론을 통해 최상의 솔루션을 찾습니다.

    #### 집중
    팀원은 주어진 기간 동안 작업의 제품 백로그를 바탕으로 작업을 수행합니다. \
    그리고 한정된 시간 내에 결과물을 제공하기 위해 선택한 작업에 집중합니다.

    #### 열린 자세
    스크럼 팀원은 개별 학습과 전반적인 프로젝트 품질을 뒷받침하는 새로운 아이디어와 기회를 열린 자세로 수용합니다.

    #### 존중
    팀원은 프로젝트 관리자, 다른 팀원, 스크럼 프로세스를 존중합니다. \
    이러한 존중의 문화는 팀 내에서 상호 협력과 협업의 정신을 만들어냅니다.


  - 따라서, 완벽하게 코드를 짜야 된다는 생각으로 인해 코드 추가에 대한 두려움을 제거해야 한다.

## 10.2 - 두려움 극복을 위한 스파이크 사용

```
스파이크란 프로젝트 초기에 스토리를 진행하기 앞서 사용할 기술(라이브러리, 프레임워크)을 조사하고,
요구사항에 관련된 배경지식을 습득하는 단계
```

- 실패에 대한 두려움이 생산성을 가로 막는다.
- 프로그래밍을 시작할 때 작업 절차로 다음과 같은 방식을 추천한다고 한다. (이를 스파이크라고 표현함)
  - `탐색` → `명세화` → `구현` → `테스트` → `리팩터링` → `전달` → `탐색` → `명세화` … 이 사이클의 반복
  - 스파이크 동안 생성된 코드는 메인으로 들어가지 않기 때문에 결함이 있는지 여부는 중요하지 않다.
- 주의점으로는 제품이 코드나 기능이 아니라 **지식**이라는 것을 인지할 필요가 있다.
- 스파이크 결과로 **슬라이드**, **스크린 샷**, **목업**으로 구성해서 시간 낭비가 아니라는 것을 보여주면 좋다.

## 10.3 - 낭비나 위험에 대한 두려움 극복을 위한 사용 시간 비율 지정

- 개발 도구와 파이프라인이 실제 프로덕션 코드보다 훨씬 더 정교한 경우 코드를 짜기 두려워진다.
- 비즈니스 로직을 작성하기 전에 **테스트 환경**, **브랜치 전략**, **레포 구조**, **프레임워크**, **CI/CD** 등 이러한 것들을 \
  구성하다가 코드를 생산하지 않으면 위의 환경을 구성한 가치가 없어진다.
  - 위와 같은 코드는 위험이나 낭비를 줄이는 데 사용해야 한다.
  - 지원 도구의 유지보수 및 개발과 같은 비기능 요구사항은 개발자 시간의 20%만 할당할 것을 권장 \
    <*데브옵스 핸드북 - 진 킴(Gene Kim, 에이콘출판사 2018)*>
  - 이를 활용할 방법으론 **비티켓 작업은 금요일에 몰아서 처리**하면 된다. (리팩터링 포함)

## 10.4 - 불완전성에 대한 두려움 극복을 위한 점진적 개선

- 임포스터 신드롬을 조심하고, 실수를 두려워 하면 안 된다.
- 완벽한 코드가 존재하지 않는다. 코드를 더 **효율적으로 만들려면 스킬과 프로파일링이 필요**하고, \
  **사용하기 쉽게 하려면 테스트와 실험**이 필요하다. 또한, **쉽게 확장하려면 리팩터링과 선견지명**이 필요하고, \
  **안정적인 코드를 만드려면 테스트나 정확한 데이터 타입의 사용**이 필요하다. 이 모든 것은 시간이 걸린다.
- 코드를 작성할 때 지표가 많으면 개발자 삶에 맞춰 최적화하는 것이 좋다.
  - 즉, 일을 받는 순간부터 작업을 시작하기까지의 시간을 최대한 짧게 만들어야 된다.
  - 이렇게 되면 테스트, 테스터, 사용자로부터 피드백 루프가 짧아진다.
  - 개발자 삶에 맞춘다는 것은 코드를 거의 바로 짜게 되는 것이다. \
    (9장의 내용과는 상반되지만, 코드에 모니터링을 추가하고 6주 후 코드가 사용 중인지 체크하는 방식)

## 10.5 - 복사 및 붙여넣기가 속도에 미치는 영향

- 스파이크 방식에선 복제를 권장하고, 스파이크가 끝나는 시점에선 통합할 수 있는지 살펴보자.
  - 즉, 6주간은 같은 코드라도 복사하면서 진행하고, 코드를 잊어버리기 전에 통합할 수 있는지 고려

## 10.6 - 확장성을 통한 추가에 의한 변경

- 일부 코드가 변경에 수용적이어야 한다면 확장 가능하게 만들어야 한다.
- 별도의 클래스로 변형을 만든다는 것을 의미한다. (추상화로 생각해도 될 거 같음)
- 도메인에 관련되지 않는 복잡성은 `우발적 복잡성(accidental complexity)`을 제한해야 한다.
  - 이를 제한하기 위해 다음의 3 단계를 따르면 좋다.
  1. 코드를 복사한다.
  2. 복사본을 가지고 작업해서 적용한다. (10.5와 같은 이야기)
  3. 합리적이라고 판단될 경우 원본과 통합한다.
  - 이 방식은 리팩터링 패턴 중 `확장-수축 패턴(Expand-Contract pattern)`과 유사하다.

## 10.7 - 추가에 의한 변경으로 이전 버전과의 호환성 확보

- 코드를 갱신할 때 의도하지 않은 부작용으로 방어하기 위해 버전 관리를 해야 한다.

> 마이크로소프트(MS)의 방식
>
> 윈도우 95의 코드가 윈도우 10에서 실행할 수 있다. (20년이 된 코드가 실행 가능)
>
> - 가장 안전한 것은 아무것도 변경하지 않는 것이다.
> - 이를 지키기 위해 변경할 때마다 수정이 아닌 새로운 메서드(또는 API)를 추가하면 된다.

## 10.8 - 기능 토글(켜기/끄기)로 추가에 의한 변경

- 코드를 자주 작은 주기로 통합하면 오류가 줄어들고 시간이 절약되며, 병합 충돌에 대한 두려움이 낮아진다.
- 코드가 병합된 후 아직 해당 기능이 사용되길 원치 않는다면 `if 블록`으로 감싸서 무시하게 하면 된다.
  - 이 값은 환경변수(일반적으로 env 파일)로 관리하는 것이 좋다.
  - 이를 기반으로 **A/B 테스트**를 적용할 수 있다. ([더 살펴보기](https://aws.amazon.com/ko/blogs/korea/cloudwatch-evidently/))
- `if` 문에서 `else`를 사용하지 말 것(4.1.1) 규칙을 위반한다. 단, **기능 토글에서의 `if` 문들은 일시적**이다.

## 10.9 - ‘추상화를 통한 분기’로 추가에 의한 변경

- 위의 `if` 블록을 추상화를 통해 `NewA`, `OldA` 같이 클래스화 할 수 있다. (분기 처리용 클래스 느낌)
  - 위 부분을 추상화하는걸 이야기한다.

## 요약

- 개발 작업 절차에 스파이크를 도입하면 잘못된 빌드에 대한 두려움을 극복하는 데 도움이 된다.
- 이해관계자에게 가치를 전달하는 데 대부분의 시간을 할애할 수 있또록 약간의 낭비를 수용할 필요가 있다.
- 코드를 작성할 때 개발자의 삶에 최적화하는 것은 연습과 생산성을 극대화한다.
- 코드 복사는 실험을 장려하지만 코드를 공유하면 취약성은 증가한다.
- 더 많은 코드를 본문으로 갖는 것은 기본 구조를 더 많이 노출하고, 리팩터링에 더 좋은 방향을 제공한다.
- 리팩터링은 우발적 복잡성을 줄이는 것을 목표로 한다.
  - 기본 도메인을 의미 있게 모델링하려면 본질적인 복잡성은 필요하다. (도메인은 원래 복잡함)
- 추가에 의한 수정은 이전 버전과의 호환성을 지원하기 때문에 기능 추가로 인한 문제 발생 시 롤백에 용이함
- 추상화를 통한 분기는 복잡한 기능 전환을 관리하는 데 도움이 된다. (A/B 테스트도 할 수 있음)