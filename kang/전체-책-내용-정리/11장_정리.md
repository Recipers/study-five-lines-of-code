# 11장 - 코드 구조 따르기

---

> 이번 장에서 다루는 내용
>
> - 제어 흐름에 행위 인코딩하기
> - 행위를 데이터 구조로 옮기기
> - 데이터에 행위 인코딩하기
> - 코드에서 활용되지 않는 구조 식별

---

## 11.1 - 범위와 출처에 따른 구조 분류

- 소프트웨어 개발에서는 여러 유형의 구조(인식 가능한 패턴)를 다룬다.
    - 이런 구조는 코드(도메인)에 있을 수 있고, 스크럼을 한다고 하면 매주 하는 행위가 될 수도 있다.
- 저자는 다음과 같이 4가지 범주로 구조를 나눈다고 한다.

    ![파이브 라인스 오브 코드.png](..%2F..%2F..%2F%ED%8C%8C%EC%9D%B4%EB%B8%8C%20%EB%9D%BC%EC%9D%B8%EC%8A%A4%20%EC%98%A4%EB%B8%8C%20%EC%BD%94%EB%93%9C.png)
    출처 : 파이브라인스 오브 코드

    - **매크로 아키텍처** : 팀 간 구조에 관한 것이다.
        - 제품이 무엇이며 다른 코드가 그것과 어떻게 상호작용 하는지에 대한 것
        - 외부 API가 어떻게 보여야 하는지, 각 팀이 어떤 데이터를 소유해야 하는지 보여준다.
        - 소프트웨어 플랫폼을 정의한다.
    - **마이크로 아키텍처** : 팀 내 구조에 관한 것이다.
        - **팀이 가치를 제공하기 위해** 무엇을 할 수 있는지, 어떤 서비스를 사용하는지, 데이터를 어떻게 구성할지, 코드를 어떻게 작성할지 등
        - 리팩터링은 이 범주에 속한다.
- **팀 간의 사람에 영향을 미친다면** 조직에서 정의한 **프로세스**와 **계층** 즉, 팀 간 커뮤니케이션 방식 안에서 작업함
    - 프로세스는 스크럼(Scrum), 칸반(kanban), 프로젝트 모델(방법론) 등을 의미한다.
    - 계층은 누구와 이야기해야 하는지를 정의하는 조직도 또는 그와 유사한 것들이다.
- **팀 내에 사람에 영향을 미친다면** 도메인 전문가가 정의하는 구조가 있다.
    - 이는 소프트웨어가 어떻게 동작해야 하는지를 정의한다.
    - 즉, 시스템은 (도메인) 전문가의 행위를 반영한다.
- 조직 구성과 해당 조직이 만든 시스템 구조는 닮는 경향이 있다. (**콘웨이 법칙, Conway’s law**)
- 사용자의 행위 또한 코드 구조에 영향을 미친다. (사용자를 재교육하는 방법?)

## 11.2 - 행위를 코드화하는 세 가지 방법

- 행위의 출처가 어디인지와 상관없이 **행위를 코드에 반영하는 3 가지 방법**이 있다.
    1. **제어 흐름**
    2. **데이터 구조**
    3. **데이터 자체**

> FizzBuzz 게임으로 예를 든다.
>

### 11.2.1 - 제어 흐름에 행위 코드화하기

- 제어 흐름은 제어 연산자, 메서드 호출, 또는 단순히 열거된 코드의 줄을 통해 행위를 텍스트로 표현한다.
- 일반적으로 사용하는 코드로 구현

### 11.2.2 - 데이터 구조에 행위 코드화하기

- 데이터 구조를 사용하여 행위를 기술한다.
- 클래스와 인터페이스로 구현 (`FizzAction 인터페이스`, `SayFizz 클래스` 등)

### 11.2.3 - 데이터 자체에 행위 코드화하기

- 문자 그대로 데이터 자체를 행위를 코드화 한 것이다.
- 정지 문제(7.1)로 인해 가장 어렵다.

## 11.3 - 구조 노출을 위한 코드 추가

- 기본 구조에 대한 확신이 없다면 리팩터링 노력을 줄이고 먼저 정확성에 집중해야 한다.
- 새로운 기능이나 하위 시스템을 구현할 때는 불확실성이 있기 때문에 클래스보다는 열거형이나 루프가 좋다.

## 11.4 - 예측 대신 관찰, 그리고 경험적 기술 사용

- 코드를 추측하지 말고 경험적인 기술을 사용해야 된다. (ex, 도요타의 카타, 증거 기반 관리 등)
- 체스를 구현한다고 해보자, 인터페이스와 클래스를 사용하는 것이 좋을까? 하드 코딩이 좋을까?
    - **객체지향**으로 체스를 구현한다고 했을 때 이점은 **변경에 용이하다는 것**이다. 하지만, \
      체스는 500년동안 변하지 않았다. 즉, 변경이 필요 없으면 하드 코딩도 좋은 방법이다.
- 변경되지 않으면 아무것도 하지 말아라 (리팩터링도 필요 없음)
- 예측할 수 없이 변경되는 경우 취약성을 피하기 위해서만 리팩터링하자.
- 그렇지 않으면, 과거에 발생한 변경 유형을 적용해 리팩터링을 적용하자.

## 11.5 - 코드를 이해하지 않고도 안전성을 확보하는 방안

### 11.5.1 - 테스트를 통한 안전성 확보

- 안전을 확보하기 위해 가장 일반적인 접근 방식은 코드를 테스트하는 것이다.
- 만약, 테스트 코드가 많아져 테스트의 시간과 관리가 어려워지면 자동화로 만들면 된다.

### 11.5.2 - 숙달을 통한 안전성 확보

- 사람이 리팩터링을 하는 것에 초점을 맞춰 실수 가능성을 줄이자.
    - 리팩터링을 작은 단계로 분할하자 (작을수록 위험이 줄어듬)
    - 이렇게 연습(반복)하다 보면 리팩터링을 기계처럼 할 수 있게 숙달된다.

### 11.5.3 - 도구의 지원을 통한 안전성 확보

- 컴파일러와 협업하기(7장) 같이 기계(IDE 등)를 이용해 인간의 실수를 줄일 수 있다.

### 11.5.4 - 공식 인증을 통한 안전성 확보

- 비행기나 화성 탐사선 같이 실패 비용이 많이 드는 소프트웨어는 버그가 없는지 공식적으로 확인할 수 있다.
    - [여기](https://www.faa.gov/aircraft/air_cert/design_approvals/product_issues_lists/transport_airplane) 말하는 건가?
- 증명 보조기(proof assistant)를 사용해서 프로그램의 논리적인 명제가 올바른지 확인할 수도 있다.

### 11.5.5 - 내결함성을 통한 안전성 확보

- 10장에서 봤듯이 기능 토글을 만들어서 실패 시 이전 버전으로 롤백하도록 만들면 된다.

## 11.6 - 활용되지 않은 구조 이용

- 기초가 견고한지, 구조가 지속될 가능성이 있는지 고려해야 된다.
- 일반적으로 기본 도메인은 소프트웨어보다 오래된 경향이 있으므로 더 성숙하고 급격한 변화가 덜 발생한다.
  따라서, 도메인으로부터 온 구조는 안전하게 활용할 수 있다.

### 11.6.1 - 추출 및 캡슐화에 공백 활용

- GWT, AAA 테스트 방식처럼 빈 줄을 이용해 코드를 지각화 하면 구조 파악에 도움이 된다.
- 코끼리를 냉장고에 넣을 때 조각내는 것처럼

### 11.6.2 - 통합에 중복 코드 활용

- 중복된 코드를 메서드 또는 클래스로 추출하면 된다.

### 11.6.3 - 캡슐화로 공통 접사 활용

- 공통적인 명칭을 통해 그룹화된 것을 발견할 때 이 구조를 견고하게 하는 방법은 **데이터 캡슐화**이다.
- 유사한 이름을 가진 클래스들을 그룹화 할 때도 사용할 수 있다.
    - 자바 - 클래스를 다른 클래스나 패키지 내에 캡슐화
    - C# - 네임스페이스를 이용
    - TS - 네임스페이스나 모듈 이용 (npm에 있는 라이브러리도 가능, [참고](https://typescript-handbook-ko.org/pages/declaration-merging.html)) ([TS 기본 Error 타입 확장 예](https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgKJSgeysg3sgegOQBUBlZQBjrAPnrQ20B9O5QVTXBS8cB1V5QYJqAoZf5CAgB3AIIAuQQFcAtgCNoAbh4BfHjCkgEYYJhDI4ACmhRJ6LFACUePgIR6AzpgA2EAHTPMAc2MY3QsUtlNSMAugtDSyCeIA))

### 11.6.4 - 동적 실행으로 런타임 유형 활용

- 인터페이스를 통한 동적 실행(dispatch)을 활용하라는 이야기

## 요약

- 코드는 개발, 프로세스 및 해당 도메인과 관련된 사람들의 행위를 반영한다.
- 제어 흐름에 인코딩된 행위(동작)는 큰 변화를 쉽게 만들 수 있다.
- 데이터 구조에 인코딩된 행위는 타입 안전성, 지역성, 성능 및 작은 변경의 용이성과 같은 장점을 제공한다.
- 데이터 인코딩에 행위는 최후의 수단으로 사용될 수 있다.
    - 단, 컴파일러 자원이 부족해서 안전하게 유지하기 어렵기 때문에 제한되어야 한다.
- 코드를 사용해서 구조를 노출하면 리팩터링을 통해 유연하게 만든 후 더 많은 구조를 추가할 수 있다.
- 경험적을 사용해서 리팩터링 시 빠르게 구조를 통찰하고 계속 변하는 것에 기반을 두면 안 된다.