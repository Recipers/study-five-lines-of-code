# 9장 - 코드 삭제의 미학
---

> 이번 장에서 다루는 내용
>
> - 코드가 개발 속도를 어떻게 늦추는지 이해하기
> - 우발적인 낭비를 방지하기 위한 한계 설정하기
> - 스트랭굴러 무화과(strangler fig) 패턴으로 전환 처리하기
> - 스파이크(spike) 및 스태빌라이즈(stabilize) 패턴으로 낭비 최소화하기
> - 도움이 되지 않는 모든 것들 제거하기

---

- 코드의 가치 여부와 관계없이 관리하기 위해 지속해서 노력해야 한다.
- 카타(Kata)와 스파이크(Splike)를 훈련하면서 나중에 바로 삭제되는 코드로 실험할 수 있다.
  - 카타 : 소프트웨어 개발 연습으로, 무술에 사용되는 훈련 방법에서 유래됐다. ([참고](https://www.samsungsds.com/kr/insights/101717_org_sw4.html))
  - 스파이크 : 실험적인 코드를 만들고 사용자의 피드백을 받는 과정을 반복하고, 최종적으로 코드는 삭제 함

## 9.1 - 다음 시대는 코드를 지우는 시대일 것이다.

- 오늘날 우리는 코드를 작성하고 시스템을 구축하는 데 능숙하다 그러나, 아직 코드 삭제는 익숙하지 않다.

## 9.2 - 복잡성을 제거하기 위한 코드 삭제

- 두 가지 복잡성에 대해 나온다.
  1. **도메인 복잡성**
    - 도메인 자체가 본질적으로 복잡하다. (ex, 세법 프로그램 → 세법은 복잡하다.)
  2. **부수적 복잡성**
    - `기술적 무지`, `기술적 낭비`, `기술적 부채`, `기술적 방해물` 이렇게 4 가지 유형이 있다고 한다.

### 9.2.1 - 경험 부족으로 인한 기술적 무지

- 지속적으로 기술을 향상시키기 위해 의도적인 연습을 해야 한다. (연습을 대신할 수 있는 것은 없다.)
  - 어려운 작업이나, 긴급 버그, .. 등 몇몇 상황에서는 페어 프로그래밍, 몹 프로그래밍이 효과적이다.

### 9.2.2 - 시간 압박으로 인한 기술적 낭비

- 부수적 복잡성에서 가장 단순한 유형이다.
- 일반적인 기술 낭비는 시간 압박에서 비롯된다. 이 때문에 테스트나 리팩터링을 건너뛰기도 한다.
- 개발자에게는 관행이 있으며 압박을 받더라도 이를 고수해야 한다. (그래도 최대한 일정을 지키는 것이 좋다.)
  - 이야기 할 거리가 많을거 같다.

### 9.2.3 - 환경에 따른 기술적 부채

- 기술 부채는 일시적으로 차선의 해결책을 선택해서 이익을 얻는 것이다.
- 의도적인 의사결정이지만 중요한 것은 일시적이라는 것이다.
  - [참고 영상](https://youtu.be/eyhitm6LWkU?t=3556) (우아콘, 김범준 CEO) - (피드백 사이클이 중요)
- 기술 부채를 발생시키는 것은 전략이며, 만료일이 있는 한 본질적으로 잘못된 것이 없다.

### 9.2.4 - 성장에 따른 기술적 장애물

- 기술적 장애문(Technical drag)은 개발을 더디게 만드는 모든 것이다.
  - 문서, 테스트 및 실존하는(기존의) 모든 코드는 물론 다른 모든 범주가 포함된다.
  - 사용하지 않는 기능, 코드, 문서, 위키 페이지, 테스트, 환경 설정 플래그, 인터페이스, 버전 관리 시스템의 브랜치 모두 삭제하자.

## 9.3 - 친밀도에 따른 코드 분류

- 친밀하게 알고 있는 코드를 삭제하는 것이 이해가 필요한 코드를 삭제하는 것보다 저렴하고 안전한다.
- 댄 노스는 코드를 작성한지 6주가 지나면 코드와의 친밀도가 떨어지기 시작한다고 한다.

## 9.4 - 레거시 시스템에서의 코드 삭제

- 레거시 코드의 일반적인 정의는 ‘**수정하기 어려운 코드**’이다.
- 이러한 코드들을 어떻게 수정할 수 있을까? - 스트랭글러 무화과 나무 패턴을 살펴보자.

### 9.4.1 - 스트랭글러 무화과나무 패턴

- 레거시 코드가 **얼마나 사용되고 있는지** 확인하는 것이다.
  - 거의 사용되지 않는 경우 추가 조사 없이 제거
  - 작은 부분만 많이 사용하는 경우에는 해당 부분만 수정하고 나머지 제거
  - 모든 것이 많이 사용된다면 코드에 익숙해지고, 안정적으로 만들어야 한다.
- 따라서, 레거시 코드에 대한 통찰력을 얻으려면 각 부분이 얼마나 호출되는지 알아야 한다.
  - 이러한 호출 중에서 성공, 실패 여부도 알아야 한다.
- 레거시 코드가 나머지 소프트웨어와 얼마나 밀접하게 연결되어 있는지 알아야 한다.
- 이 과정을 돕기 위해 마틴 파울러는 ‘[스트랭글러 무화과나무](https://martinfowler.com/bliki/StranglerFigApplication.html)’ 패턴을 제시했다. - [기계 인간님 글 참고](https://johngrib.github.io/wiki/pattern/strangler/)
  - 기존 나무 줄기에 씨를 뿌리고 자라면서 숙주를 감싸 숙주 나무를 교살해 죽이는 나무이다.
  - 여기서 기존 나무 즉, 숙주는 레거시 시스템이다.
  - 코드 조각이 얼마나 밀접하게 결합되어 있는지 알아보기 위해 코드를 분리한다.

### 9.4.2 - 코드 개선을 위한 스트랭글러 무화과나무 패턴 사용

- 어떤 항목이 호출되는 빈도는 일반적으로 그것이 얼마나 중요한지를 나타내는 좋은 지표이다.
- 이 책의 저자분은 쉬운 결정부터 시작하는 것을 선호한다고 한다.
  - 가장 많이 호출되는 부분은 마이그레이션, 가장 적게 호출되는 부분은 웬만하면 삭제한다.
  - 몸통 부분은 가장 적게 또는 항상 실패하는 **코드를 비판적으로 평가**해서 판단한다.

## 9.5 - 동결된 프로젝트에서 코드삭제

### 9.5.1 - 바람직한 결과를 기본값으로 설정

- 프로젝트가 코드베이스 외부에 영향을 미치지 않으면(ex, DB 등) 태그를 지정하고 6주 후 태그를 삭제한다고 메모를 작성.
  - 6주 안에 프로젝트를 사용하지 않으면 제거될 것이라는 것을 의미
  - 수정할 것이 없는 기능이면 어떻게 해야 되지?

### 9.5.2 - 스파이크와 스태빌라이즈(안정화)로 낭비 줄이기

- 중대한 변경 사항을 구현할 때 노력을 절약하는 방법으론 댄노스의 스파이크와 스태빌라이즈 패턴을 사용하자
  - 스파이크와 스태빌라이즈(spike & stabilize) 패턴
    - 프로젝트를 스파이크로 취급한다.
    - 가능한 프로젝트를 일반 애플리케이션과 별도로 구현하고 고품질에 노력을 기울이지 않는다.
    - 즉, 자동화된 테스트와 리팩터링이 없는 것이다. (그러나, 모니터링이 포함되어 코드의 사용량 파악)
    - 6주 후 코드로 돌아가 코드가 얼마나 사용되었는지 확인한다. → 많이 사용 됐으면 재구현 (품질 Up)
    - 잘 사용되지 않는 코드면 삭제한다.

## 9.6 - 버전 관리에서 브랜치 삭제

- main에 병합되면 사용한 브랜치는 삭제하자.

### 9.6.1 - 브랜치 제한으로 낭비 최소화

- 칸반 보드를 이용하자. (ex, 지라, github Project board 등)
- 팀에서 작할 수 잇는 티켓 수의 상한선을 정해두고, 브랜치의 생성을 제한한다.

## 9.7 - 코드 문서 삭제

- 문서는 세 가지 조건을 충족해야 한다.
  - 관련성 : 올바른 질문에 답해야 한다.
  - 정확성 : 답은 정확해야 한다.
  - 발견 가능성 : 답을 찾을 수 있어야 한다.
- 위 같은 속성이 없을 경우 문서의 가치가 크게 떨어진다.

## 9.8 - 테스트 코드 삭제

### 9.8.1 - 낙관적 테스트 삭제

- 그린 테스트를 통해 코드의 동작을 신뢰할 수 있어야 한다. 하지만 낙관적인 테스트를 짜면 신뢰할 수 없다.
- 실패할 수 없는 테스트는 가치가 없다. (검증을 위해 테스트를 사용하는데 동일한 말을 반복하는 테스트는 x)

### 9.8.2 - 비관적 테스트 삭제

- 낙관적 테스트에선 그린(green) 테스트라고 했다면 여기는 레드(red) 테스트이다.

### 9.8.3 - 불안정 테스트 수정 또는 삭제

- **항상 같은 결과를 내지 않는 예측할 수 없는** 레드, 그린 테스트가 있는데 이를 **불완정 테스트**라고 한다.

### 9.8.4 - 복잡한 테스트를 제거하기 위한 코드 리팩터링

- 모든 리팩터링 노력은 테스트가 아니라 코드에 집중해야 한다.

### 9.8.5 - 속도를 높이는 테스트 문화

- 느린 테스트와 빠른 테스트를 분리하고 가능한 한 자주 빠른 퀘스트를 지속적으로 실행해야 한다.

## 9.9 - 설정 코드 삭제

- 하드코딩된 값을 상수로 추출하자.

### 9.9.1 - 설정의 예상 수명으로 범위 지정

- **실험을 위한 설정**
  - **베타 테스트** 또는 **A/B 테스트**라고 한다.
- **과도기적인 설정**
  - 비즈니스 또는 코드 베이스가 중요 변경 사항을 겪고 있는 동안 유용하다.
    - 릴리스와 배포를 연결하자. (CI / CD)
    - 일반적인 전환을 한 번 완료하고, 스트랭글러 무화과나무 패턴을 사용해서 오래된 코드 제거
- **영구적인 설정**
  - 영구적인 설정 부분이 사용량을 증가시키거나 유지보수가 간편해야 특별하다.

## 9.10 - 라이브러리 제거를 위한 코드 삭제

- 라이브러리를 자주 사용하지만, 이 부분은 양날의 검이다.
  - 코드를 유지보수 할 필요는 없지만, 때에 따라 해당 버전을 업데이트 해야 된다.
  - 또한, 라이브러리를 사용하면 구성원이 작업을 위한 최소한의 라이브러리 지식이 필요하다.

### 9.10.1 - 외부 라이브러이에 대한 의존도 제한

- 그렇다고 모든 [바퀴를 다시 만들](https://kimck.tistory.com/entry/%EB%B0%94%ED%80%B4%EB%A5%BC-%EB%8B%A4%EC%8B%9C-%EB%B0%9C%EB%AA%85%ED%95%98%EC%A7%80-%EB%A7%88%EB%9D%BCDont-reinvent-the-wheel) 필요는 없을거 같다.

## 9.11 - 작동 중인 기능에서 코드 삭제

- 코드는 부채이다. 쓸모 없는 코드가 삭제 될 수록 남아 있는 코드들의 가치는 높아진다.
- 코드가 있다면 → 충분히 사용되는가? → 유지비가 비싼가? → 개선할 수 있는가? 를 생각해보자.
  - 작동중이라면 작동중인 기능에 대해서도 비판적으로 생각하고, 비용을 줄일 방법을 찾아보자.