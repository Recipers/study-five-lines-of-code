## 9장 내용 정리

### 코드 삭제의 미학

- 시스템에는 어느정도 오래 지속되는 코드가 필요함
- 도메인의 복잡성에 따라서 필요한 코드의 양은 다름
- **적은 것이 낫다**

1. 다음 시대는 코드를 지우는 세대가 될 것
    - 1994년 : 컴퓨터를 사용해서 추상화 없는 계산을 수행
    - 1952년 : 그레이스 호퍼가 최초의 링커(linker)를 발명해서 컴퓨터가 순수한 계산 대신 기호로 작업할 수 있게 함
    - 1957년 : 앞선 도약은 컴파일러, 특히 포트란의 발명으로 이어짐, 이제 루프와 같은 높은 수준의 제어 연산자를 사용해서 코딩
    - 1972년 : 데이터 추상화, 언어의 새로운 시대에 접어들게 됨. C와 C++, 자바 같은 프로그래밍 언어는 포인터와 참조를 통해 간접적으로 데이터를 사용
    - 1994년 : 재사용 가능한 디자인 패턴을 만듣 4인방 (에릭 감마, 리처드 헬름, 랄프 존슨, 존 블리시디스)으로 인해 또 한 번 큰 도약. 디자인 패턴은 구축할
      소프트웨어를 설계할 때 높은 수준의 빌딩 블록 역할을 함
    - 1999년 : 마틴 파울러는 표준 리팩터링 때턴의 카탈로그를 만듬. 미리 설계할 필요가 없지만 기존 코드의 설계를 개선할 수 있음
    - 2011년 : 샘 뉴먼에 의해 마이크로서비스 아키텍처가 대중화됨. 마이크로서비스 아키텍처는 느슨한 결합의 오래된 원리를 기반으로 하지만 현대적인 확장문제를 해결, 또한
      간접적인 커뮤니케이션을 통해 새로운 아키텍처를 구현할 수 있으며, 실행 중인 시스템의 설계를 개선할 수 있음

2. 복잡성을 제거하기 위한 코드 삭제
    - 더 큰 코드베이스는 커플링으로인해 더 복잡한 모델이 필요하고, 추적을 위한 더 큰 유틸리티 라이브러리가 필요
    - 도메인 복잡성
        - 도메인이 기본적으로 가지고 있는 것
        - 해결하고자 하는 문제가 기본적으로 복잡함
    - 부수적 복잡성
        - 도메인에서 요구하지 않은 사항
        - 우연히 추가된 모든 복잡성

        1. 기술적 무지 (경험 부족)
            - 정말 모르거나 배울 시간이 없기 때문에 불필요한 결합을 추가하지않고도 문제를 해결할 수 있는 기술이 부족해서 발생
            - 공동 프로그래밍을 통해 지식을 공유해야함
            - 의도적인 연습으로 기술을 향상시키기 위해 노력해야 함
        2. 기술적 낭비 (시간 압박)
            - 문제나 모델을 충분히 이해하지 못하기 때문에 테스트나 리팩터링을 건너뜀
            - 기한을 맞추기 위해 프로세스를 우회하기도 함
        3. 기술적 부채 (환경)
            - 일시적으로 차선의 해결책을 선택해서 이익을 얻는 것
            - 적절한 아키텍처에 대한 고려 없이 핫픽스(hotfix)를 구현하고,
            - 중요한 문제를 해결하기 위해 적용(push)한 다음 나중에 적절한 수정을 구현하기 위해 다시 해야할 때 이런 일이 자주 발생
        4. 기술적 방해물 (성장)
            - 문서, 테스트 및 기존의 모든 코드는 물론, 다른 모든 범주가 포함
            - 자동화된 테스트는 태스트 코드도 (의도적으로) 변경해야 하므로 코드를 변경하기 어렵게 만듬
            - 문서는 무언가를 변경할 때 반드시 업데이트 해야하기 때문에 개발속도를 늦춤
            - 더 이상 삭제할 것이 없을 때까지 가능한 한 많은 것을 삭제히는 것이 해결책
            - 사용하지 않거나 불 펼요한 기능, 코드, 문서, 위키 페이지, 테스트, 환경 설정 플래그, 인터페이스, 버전 관리 시스템의 브랜치 등을 모두 삭제

3. 친밀도에 따라 코드 분류
    - 최근에 개발한 코드에 가장 익숙함
    - 친밀하게 알고 있는 코드륵 먼저 삭제하는 것이 이해를 해야하는 코드를 삭제하는 것 보다 저렴하고 안전

4. 레거시 시스템에서의 코드 삭제
    - 레거시 코드란 일반적으로 **수정하기 겁나는 코드**
    - 서커스 팩터
        - 프로젝트를 진행하는 텀원 중 얼마나 많은 사람이 갑작스럽게 빠져야 프로젝트가 중단되거나 심각한 상황에 놓이는지를 가리키는 지표
        - "이건 ~~ 밖에 못하는데?" 라는 말이 나오면 서커스 팩터가 있다고 한다
        - 서커스 팩터를 잃는 순간 건드리기 꺼려지는 레거시 코드가 생기게 됨
    - 스트랭글러 무화과나무 패턴
        - 레거시 코드가 얼마나 사용되고 있는지 확인하는 것
        - 각 부분이 얼마나 호출되는지 알아야 하고,
        - 얼마나 많은 호출이 성공했는지 알아야 함
        - 기존 나무 줄기에 씨를 뿌리고 자라면서, 숙주를 감싸 궁극적으로 숙주 나무를 교실해 죽이는 나무에서 명 따옴
        - 레거시 코드
            ```javascript
            class LegacyA {
              static a() { ... }
            }
            class LegacyB {
              b() { ... }
            }
            LegacyA.a();
            let b = new LegacyB(); 
            b.b(); 
            ```
        - 스트랭글러 무화과나무 패턴 적용 코드
            ```javascript
            namespace Legacy {
              class LegacyA {
                static a() { ... }
              }
              class LegacyB {
                b() { ... }
              }
              export class Gate {
                a() {
                  try {
                    let result = LegacyA.a();
                    Logger.log("a success");
                    return result;
                  } catch (e) {
                    Logger.log("a fail");
                    throw e;
                  }
                }
                bClass() {
                  try {
                    let result = new LegacyB();
                    Logger.log("bClass success");
                    return result;
                  } catch (e) {
                    Logger.log("bClass fail");
                    throw e;
                  }
                }
              }
            }
            let gate = new Legacy.Gate(); gate.a();
            let b = gate.bClass();
            b.b();
            ```
        - Gate를 변경하고 리팩토링해서 새 버전으로 전환하거나,
        - 중요하지 않고, 전략적이지 않은 경우에는 삭제

5. 동결된 프로젝트(frozen project)에서 코드 삭제
    - 다른 작업을 하는 동안 진행이 멈춰 있는 프로젝트? 잊어버린 프로젝트?
    - 코드에 국한되지 않고, 데이터베이스 테이블, 통합, 서비스 등 많은 항목들이 포함됨
    - 6주안에 사용되지 않는 다면 제거? (그것도 스크립트를 만들면서까지?)
    - 스파이크 & 스태빌라이즈 패턴 사용
        - 스파이크 : throw away, prototype code (실험적인 안정화 되지 않은 코드)
        - 스태빌라이즈 : 스파이크를 모니터링 or 사용자 피드백을 통해 유용하다고 판단되면 고품질의 안정화된 코드로 변경

6. 버전 관리에서 브랜치 삭제
    - 브랜치가 저렴하면 브랜치를 제거히는데 게을러지는 경향이 있음
    - 시간이 지남에 따라 브랜치가 축적되는 경우가 있음
        - 긴급 패치(hotfix)를 수행하기 위해
        - 커밋에 태그를 지정히면 release처럼 해당 위치로 되돌아 갈 수 있음
        - 다른 사람의 업무를 방해하지 않고 일하기 위해
    - 진행 중인 작업(WIP : work in progress) 제한

7. 코드 문서 삭제
    - 위키 페이지, Javadoc, 설계 문서, 튜토리얼 등 다양한 형태
    - 코드 문서는 다음의 조건을 충족해야 함, 셋 중 하나라도 누락되면 가치가 크게 떨어짐
        - 관련성 : 올바른 질문에 답해야 함
        - 정확성 : 답이 정확해야 함
        - 발견 가능성 : 답을 찾을 수 있어야 함
    - 문서화 하는 것이 의미가 있는지 결정 할 때 아래와 같은 절차를 수행함
        1. 문서화 대상이 지주 바뀌면 문서화 해서 얻을 것이 없음 (문서화 X)
        2. 드물게 사용하면 문서화 함
        3. 근데, 자동화 할 수 있으면 자동화 함
        4. 아니면 외워야 함
    - 문서 사용을 늘리기 위해 최신화를 자주 해야 함

8. 테스트 코드 삭제
    1. 낙관적 테스트 코드 삭제
        - 실패 할 수 없는 테스트 코드는 가치가 없음
    2. 비관적 테스트 코드 삭제
        - 오류가 발견되더라도 피로를 느껴, 중대한 오류를 놓칠 위험이 있음
    3. 불안정 테스트 수정 또는 삭제
        - 항상 같은 결과를 내지 않는 예측할 수 없는 테스트
        - 어떤 조치도 이끌어 낼 수 없음
    4. 복잡한 테스트 코드를 삭제하기 위한 리팩터링
        - 모든 리팩터링 노력은 테스트가 아니라 코드에 집중되어야 함
    5. 속도를 높이는 테스트 문화
        - 느린 테스트와 빠른 테스트를 분리
        - 빠른 테스트릃 지속적으로 실행하거나,
        - 느린 테스트의 실패 원인을 관찰하고, 관련이 없으면 제거

9. 설정 코드 삭제
    - 설정성을 추가할 때마다 코드의 복잡성도 증가
      > 완벽하게 만들 수 없다면 최소한 설정이 가능하게 만들어라.  
      > -맥심
    - 각 옵션을 모든 플래그에 대해 태스트해야 하기 때문에 테스트 양이 두 배로 증가
    - 설정의 예상 수명으로 범위를 지정
        1. 실험을 위한 설정
            - 무엇이 실험을 위한 설정인지를 처음부터 결정하고 테스트가 완료되는 즉시 제거
        2. 과도기적인 설정
            - 비즈니스 또는 코드베이스가 중요 변경사항을 겪고 있는 동안 유용함
            - 장기적으로 복잡성이 증가하고 높은 비용을 치뤄야 함
            - 많은 유형의 전환이 사용자에게는 잘 보이지 않음
                - 다른 설정 플래그들보다 코드에 더 밀접하게 관련되어 있음
            - 일반적으로 전환이 완료되고 오래된 부분을 제거할 수 있는 위치에 있음
        3. 영구적인 설정
            - 시용량을 증가시키거나 유지보수가 간편해야 하기 때문에 특별함
            - 시용량이 증가하지 않고 유지보수가 간단하지 않은 경우 비용 가치가 없으므로 제거

10. 라이브러리 제거를 위한 코드 삭제
    - 많은 기능을 저렴하게 얻는 방법은 써드파티 라이브러리를 이용하는 것
    - 써드파티 라이브러리의 보안 품질이 소프트웨어 생존성에 직접적인 영향을 미칠 수 있음 (ex : log4j)
    - 라이브러리를 사용하는 것은 양날의 검
        - 업데이트에 따른 코드 수정이 필요할 수 있음
        - 구성원이 작업을 위한 최소한의 지식을 보유해야 하기 때문에 팀의 제한된 인지부하{finite cognitive)를 더하게 됨
    - 외부 라이브러리에 대한 의존도 제한
        - 고품질의 라이브러리만 사용하기
        - 자주 업데이트 하기 -> 사실 별로 도움이 되지 않음
        - 종속성을 가시적으로 만든 다음, 개선 용도인지 중요 용도인지 구분
            - 개선용 라이브러리가 손상되면 대체 라이브러리를 찾기
            - 사용하지 않는 라이브러리가 있다면 제거하기
            - ex : jquery를 설치했지만 ajax 호출 용도로만 사용하고 있다면 요구에 맞는 단순한 라이브러리로 대체

11. 작동중인 기능에서 코드 삭제
    - 작동중인 기능에 대해서 비판적으로 판단하고 감당하지 못 할 경우 제거

    1. 충분히 사용되는가?
    2. 유지비가 비싼가?
    3. 개선할 수 있는가?